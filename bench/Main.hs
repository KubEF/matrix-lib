module Main where

import Criterion
import Criterion.Main (defaultMain)
import Data.List (unfoldr)
import GHC.Word
import GenTH
import Matrix
import ParseMTX
import System.Random

pureGen :: StdGen
pureGen = mkStdGen 137

generateRndList :: Int -> [Word64]
generateRndList n = take n (unfoldr (Just . genWord64) pureGen)

add10 :: (Num a) => a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a
add10 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10

appl :: [b -> c] -> [b] -> [c]
appl = zipWith ($)

trueZipWith10 :: (a -> b1 -> b2 -> b3 -> b4 -> b5 -> b6 -> b7 -> b8 -> b9 -> c) -> [a] -> [b1] -> [b2] -> [b3] -> [b4] -> [b5] -> [b6] -> [b7] -> [b8] -> [b9] -> [c]
trueZipWith10 func l1 l2 l3 l4 l5 l6 l7 l8 l9 l10 = map func l1 `appl` l2 `appl` l3 `appl` l4 `appl` l5 `appl` l6 `appl` l7 `appl` l8 `appl` l9 `appl` l10

trueThrough4Matrix :: (Applicative f) => (a1 -> a2 -> a1) -> f a1 -> f a2 -> f a2 -> f a2 -> f a1
trueThrough4Matrix binFunc m1 m2 m3 m4 = fmap binFunc (fmap binFunc (fmap binFunc m1 <*> m2) <*> m3) <*> m4

main :: IO ()
main = do
    m1 <- readFuncToMatrix "bench/1138_bus.mtx"
    m2 <- readFuncToMatrix "bench/meg4.mtx"
    m3 <- readFuncToMatrix "bench/ex31.mtx"
    let matrix1 = Matrix m1
        matrix2 = Matrix m2
        matrix3 = Matrix m3
    defaultMain
        [ bgroup
            "benches through4Matrix generated by TH"
            [ bench "matrix1" $ nf (trough4Matrix (+) matrix1 matrix1 matrix1) matrix1
            , bench "matrix2" $ nf (trough4Matrix (+) matrix2 matrix2 matrix2) matrix2
            , bench "matrix3" $ nf (trough4Matrix (+) matrix3 matrix3 matrix3) matrix3
            ]
        , bgroup
            "benches through4Matrix generated by me honest"
            [ bench "matrix1" $ nf (trueThrough4Matrix (+) matrix1 matrix1 matrix1) matrix1
            , bench "matrix2" $ nf (trueThrough4Matrix (+) matrix2 matrix2 matrix2) matrix2
            , bench "matrix3" $ nf (trueThrough4Matrix (+) matrix3 matrix3 matrix3) matrix3
            ]
        ]
